# APRS RF Decoder for ESP32C3

一个基于ESP32C3和SX1276/SX1278的高性能APRS解码器，使用Arduino框架开发。

## 项目简介

本项目实现了一个完整的APRS (Automatic Packet Reporting System) 射频解码器，能够接收和解码144.64 MHz频段的APRS数据包。解码器使用数字信号处理技术从RF信号中提取APRS消息，并通过UART输出标准TNC2格式数据。

### 主要特性

- ✅ **高性能AFSK解调**：基于数字相关器和能量检测，采样率26.4kHz
- ✅ **精确的时钟恢复**：数字PLL实现，确保稳定的比特同步
- ✅ **完整的协议栈**：AFSK → NRZI → AX.25 → APRS
- ✅ **CRC校验**：自动验证AX.25帧的FCS (Frame Check Sequence)
- ✅ **TNC2格式输出**：兼容标准APRS软件
- ✅ **实时性能监控**：统计信息、错误率、信号质量指标
- ✅ **模块化设计**：清晰的代码结构，易于维护和扩展

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      SX1276/SX1278                         │
│               (FSK Direct Mode Output)                      │
└────────────────────┬────────────────────────────────────────┘
                     │ DIO2 (26.4kHz采样)
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                   AFSK解调器                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  数字相关器  │→ │  能量计算   │→ │   比特判决   │    │
│  │ (1200/2200Hz)│  │             │  │    (PLL)     │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└────────────────────┬────────────────────────────────────────┘
                     │ 解调后的比特流
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                   NRZI解码器                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  NRZI解码    │→ │  比特去填充  │→ │  帧标志检测  │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└────────────────────┬────────────────────────────────────────┘
                     │ 字节流
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                  AX.25解析器                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │  地址解析    │→ │  FCS校验     │→ │  信息提取    │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└────────────────────┬────────────────────────────────────────┘
                     │ APRS消息
                     ↓
┌─────────────────────────────────────────────────────────────┐
│                  UART输出 (9600bps)                         │
│              格式: SOURCE>DEST:INFO                         │
└─────────────────────────────────────────────────────────────┘
```

## 硬件要求

### 必需硬件

1. **ESP32C3开发板**
   - 推荐型号：ESP32-C3-DevKitM-1 或兼容板
   - 需要支持Arduino框架

2. **SX1276/SX1278 LoRa模块**
   - 推荐频段：144 MHz (APRS频段)
   - 需要支持FSK模式和直接模式输出

3. **天线**
   - 144 MHz谐振天线或宽带天线

### 硬件连接

```
ESP32C3          SX1276/SX1278
-------          -------------
GPIO 5    <-->   NSS (CS)
GPIO 2    <-->   DIO0
GPIO 9    <-->   RESET
GPIO 3    <-->   DIO1
GPIO 4    <-->   DIO2 (数据输出)
3.3V      <-->   VCC
GND       <-->   GND

UART1输出:
GPIO 21   --->   TX (9600 baud)
GPIO 20   <-->   RX (可选)
```

**注意**：请根据实际使用的ESP32C3开发板调整引脚定义，在 `src/aprs_config.h` 中修改。

## 软件依赖

### Arduino IDE 设置

1. 安装 **Arduino IDE** 2.0 或更高版本
2. 安装 **ESP32 开发板支持**：
   - 在Arduino IDE中，打开 `文件` → `首选项`
   - 在"附加开发板管理器网址"中添加：
     ```
     https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json
     ```
   - 打开 `工具` → `开发板` → `开发板管理器`
   - 搜索"ESP32"并安装

### 库依赖

1. **RadioLib** (必需)
   - 在Arduino IDE中打开 `工具` → `管理库`
   - 搜索"RadioLib"并安装最新版本
   - 或访问：https://github.com/jgromes/RadioLib

## 安装和配置

### 1. 克隆或下载项目

```bash
git clone https://github.com/your-username/aprs-rf-decoder.git
cd aprs-rf-decoder
```

### 2. 配置硬件参数

编辑 `src/aprs_config.h` 文件，根据实际硬件调整：

```cpp
// SX1276/SX1278引脚定义
#define SX127X_NSS      5
#define SX127X_DIO0     2
#define SX127X_RESET    9
#define SX127X_DIO1     3
#define SX127X_DIO2     4

// UART配置
#define UART_TX_PIN     21
#define UART_RX_PIN     20

// APRS频率 (根据当地法规调整)
#define APRS_FREQUENCY  144.64  // MHz
```

### 3. 编译和上传

1. 在Arduino IDE中打开 `aprs-rf-decoder.ino`
2. 选择正确的开发板：`工具` → `开发板` → `ESP32C3 Dev Module`
3. 选择正确的端口：`工具` → `端口`
4. 点击"上传"按钮

### 4. 监控输出

1. 打开串口监视器：`工具` → `串口监视器`
2. 设置波特率为 **115200**
3. 系统启动后会显示初始化信息和接收到的APRS消息

## 使用说明

### 基本操作

1. **启动系统**：上电后，系统会自动初始化并开始监听APRS频段
2. **接收消息**：当接收到有效的APRS数据包时，会在串口监视器和UART1输出
3. **性能监控**：每30秒输出一次统计信息（可在配置文件中调整）

### 输出格式

#### UART输出 (TNC2格式)

```
CALL-1>APRS,WIDE1-1:!3751.50N/12139.00W>Hello World
```

#### 串口监视器输出

```
========== APRS MESSAGE ==========
From: CALL-1
To: APRS
Path: WIDE1-1
Type: 0
Position: 37.858333, -121.650000
Comment: Hello World
TNC2: CALL-1>APRS,WIDE1-1:!3751.50N/12139.00W>Hello World
==================================
```

### 性能统计

系统会定期输出以下统计信息：

- **AFSK解调器**：总比特数、错误率、PLL锁定状态、信号质量
- **NRZI解码器**：处理的比特数、比特填充计数、帧计数
- **AX.25解析器**：总帧数、有效帧数、CRC错误数、成功率
- **APRS解码器**：总消息数、位置报告数、解析错误数
- **系统资源**：空闲堆内存、循环时间、运行时间

## 代码结构

```
aprs-rf-decoder/
├── aprs-rf-decoder.ino      # 主程序
├── src/
│   ├── aprs_config.h         # 配置文件
│   ├── afsk_demod.h          # AFSK解调器头文件
│   ├── afsk_demod.cpp        # AFSK解调器实现
│   ├── nrzi_decoder.h        # NRZI解码器头文件
│   ├── nrzi_decoder.cpp      # NRZI解码器实现
│   ├── ax25_parser.h         # AX.25解析器头文件
│   ├── ax25_parser.cpp       # AX.25解析器实现
│   ├── aprs_decoder.h        # APRS解码器头文件
│   └── aprs_decoder.cpp      # APRS解码器实现
├── reference-file/           # 参考文件和示例
└── README.md                 # 本文件
```

## 技术细节

### AFSK解调

采用**数字相关器**方法：

1. **采样率**：26.4 kHz (26400 = 1200×22 = 2200×12)
2. **频率检测**：使用本地振荡器与接收信号相关
   - Mark (1200 Hz)：22个采样/周期
   - Space (2200 Hz)：12个采样/周期
3. **能量比较**：计算Mark和Space的能量，进行比特判决
4. **时钟恢复**：数字PLL跟踪比特边沿，动态调整采样相位

### NRZI解码

AX.25使用NRZI (Non-Return-to-Zero Inverted)编码：

- **比特0**：电平跳变
- **比特1**：电平保持

### 比特去填充

AX.25使用比特填充防止数据中出现帧标志：

- 连续5个1后插入一个0
- 解码器自动检测并移除填充比特

### AX.25帧结构

```
┌──────┬─────────┬─────────┬───────────┬─────────┬─────┬─────┬─────┬──────┐
│ Flag │ Dest    │ Source  │ Digis     │ Control │ PID │ Info│ FCS │ Flag │
│ 0x7E │ (7 B)   │ (7 B)   │ (0-56 B)  │ (1 B)   │(1 B)│     │(2 B)│ 0x7E │
└──────┴─────────┴─────────┴───────────┴─────────┴─────┴─────┴─────┴──────┘
```

### CRC校验

使用 **CRC-16-CCITT** 算法：

- 多项式：0x1021
- 初始值：0xFFFF
- 最终异或：0xFFFF

## 调试和优化

### 调试级别

在 `src/aprs_config.h` 中设置调试级别：

```cpp
#define DEBUG_LEVEL  DEBUG_LEVEL_INFO  // NONE, ERROR, INFO, DEBUG, VERBOSE
```

### 性能优化建议

1. **降低调试输出**：设置 `DEBUG_LEVEL` 为 `DEBUG_LEVEL_NONE` 可提升性能
2. **调整缓冲区大小**：根据实际需求调整各级缓冲区大小
3. **使用定点数**：在配置中启用 `USE_FIXED_POINT` (当前默认使用浮点数)

### 常见问题

#### 1. 无法接收到任何信号

- 检查硬件连接
- 确认天线是否正确连接
- 检查频率设置是否正确
- 确认APRS频段在当地是否有活跃电台

#### 2. 接收到信号但解码失败

- 检查PLL锁定状态和信号质量
- 调整 `ENERGY_THRESHOLD_RATIO` 参数
- 增加天线增益或改善接收位置

#### 3. CRC校验总是失败

- 检查NRZI解码是否正确
- 确认比特去填充工作正常
- 检查信号质量是否足够

#### 4. 系统崩溃或重启

- 检查堆内存使用情况
- 减小缓冲区大小
- 降低采样率（不推荐）

## 性能指标

在理想条件下的典型性能：

- **解码成功率**：> 95%
- **CRC错误率**：< 5%
- **循环时间**：< 1000 μs
- **内存占用**：< 50 KB

## 法律和许可

### 业余无线电许可

**重要提示**：在大多数国家/地区，使用APRS频段需要有效的业余无线电操作执照。请确保：

1. 您拥有有效的业余无线电执照
2. 使用的频率符合当地法规
3. 仅接收而不发射（本项目仅实现接收功能）

### 软件许可

本项目使用 MIT 许可证。详见 LICENSE 文件。

## 贡献

欢迎贡献！如果您有改进建议或发现bug，请：

1. Fork 本仓库
2. 创建您的特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交您的更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 开启一个 Pull Request

## 致谢

- **RadioLib**：https://github.com/jgromes/RadioLib - 优秀的射频库
- **APRS协议**：Bob Bruninga, WB4APR - APRS协议的发明者
- **参考实现**：RadioLib作者的APRS接收实验

## 联系方式

- 项目主页：https://github.com/your-username/aprs-rf-decoder
- 问题反馈：https://github.com/your-username/aprs-rf-decoder/issues

## 更新日志

### v1.0.0 (2025-11-16)

- ✅ 初始版本发布
- ✅ 实现AFSK解调
- ✅ 实现NRZI解码和比特去填充
- ✅ 实现AX.25帧解析
- ✅ 实现APRS消息解码
- ✅ 添加UART输出
- ✅ 添加性能监控和统计

---

**73!** (业余无线电问候语)

